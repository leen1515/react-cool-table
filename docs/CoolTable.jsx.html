<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: CoolTable.jsx</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: CoolTable.jsx</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, { useState, useMemo } from "react";
import { columns } from "./utils/columns.js";
import HeaderTable from "./components/HeaderTable.jsx";
import LinesTable from "./components/LinesTable.jsx";
import "./style/coolTable.css";
import { columnSelected } from "./utils/columnSelected.js";
import NumberRowSelector from "./components/NumberRowSelector.jsx";
import { flattenObject } from "./utils/flattenObject.js";



/**
 * @namespace Table
 * 
 **/

/**
 * @name CoolTable
 * @function
 * @description
 * A customizable and sortable table component. It allows excluding certain columns, 
 * provides search functionality, and supports sorting. The table renders data passed to it,
 * applying column formatting and sorting based on user interactions.
 *
 * @param {Array&lt;Object>} data - The data to be displayed in the table.
 * @param {Array&lt;string>} excludedColumns - The columns to be excluded from the table.
 * @returns {React.Component} A React component representing a dynamically generated table.
 */

function CoolTable({ data, excludedColumns }) {
  const [searchQuery, setSearchQuery] = useState("");
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [sortConfig, setSortConfig] = useState({ key: null, direction: null });

  const formatData = columnSelected(data, excludedColumns);
  const columnsName = columns(formatData, true);
  const columnsRef = columns(formatData, false);

  const [resetPaginationKey, setResetPaginationKey] = useState(0); 

  const getDataType = (value) => {
    if (!isNaN(Date.parse(value)) &amp;&amp; !isNaN(new Date(value).getDate())) {
      return "date";
    } else if (!isNaN(value) &amp;&amp; typeof value !== "string") {
      return "number";
    }
    return "string";
  };

  const filteredLines = useMemo(() => {
    return searchQuery
      ? formatData.filter(line => {
          const flatLine = flattenObject(line);
          return Object.values(flatLine).some(value =>
            String(value).toLowerCase().includes(searchQuery.toLowerCase())
          );
        })
      : formatData;
  }, [formatData, searchQuery]);

  const sortedLines = useMemo(() => {
    let sortableItems = [...filteredLines];
    if (sortConfig.key &amp;&amp; sortConfig.direction !== null) {
      sortableItems.sort((a, b) => {
        const aValue = a[sortConfig.key];
        const bValue = b[sortConfig.key];
        const type = getDataType(aValue);

        if (aValue == null &amp;&amp; bValue == null) return 0;
        if (aValue == null) return -1;
        if (bValue == null) return 1;

        switch (type) {
          case "date":
            return (new Date(aValue) - new Date(bValue)) * (sortConfig.direction === "ascending" ? 1 : -1);
          case "number":
            return (aValue - bValue) * (sortConfig.direction === "ascending" ? 1 : -1);
          default:
            return aValue.localeCompare(bValue) * (sortConfig.direction === "ascending" ? 1 : -1);
        }
      });
    }
    return sortableItems;
  }, [filteredLines, sortConfig]);

  const handleSortChange = (key) => {
    let direction = "ascending";
    if (sortConfig.key === key &amp;&amp; sortConfig.direction !== null) {
      direction = sortConfig.direction === "ascending" ? "descending" : "ascending";
    }
    setSortConfig({ key, direction });
  };


  const handleSearchChange = (e) => {
    const value = e.target.value;
    setSearchQuery(value);
    setResetPaginationKey(prevKey => prevKey + 1);
  };


  if (!data) return null;

  return (
    &lt;div className="cool-table">
      &lt;div className="cool-head-table">
        &lt;NumberRowSelector rowsPerPage={rowsPerPage} setRowsPerPage={setRowsPerPage} />
        &lt;div className="cool-search-input-container">
          &lt;label htmlFor="search">Search:&lt;/label>
          &lt;input
            name="search"
            id="search"
            type="text"
            value={searchQuery}
            onChange={(e) => handleSearchChange(e)}
          />
        &lt;/div>
      &lt;/div>
      &lt;HeaderTable columnsName={columnsName} columnsRef={columnsRef} onSortChange={handleSortChange} sortConfig={sortConfig} />
      &lt;LinesTable linesValues={sortedLines} columnsName={columnsRef} rowsPerPage={rowsPerPage} resetPaginationKey={resetPaginationKey} />
    &lt;/div>
  );
}

export default React.memo(CoolTable);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="Table.html">Table</a></li><li><a href="utils.html">utils</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CoolTable">CoolTable</a></li><li><a href="global.html#HeaderTable">HeaderTable</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sun Dec 17 2023 14:06:34 GMT+0100 (heure normale dâ€™Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
